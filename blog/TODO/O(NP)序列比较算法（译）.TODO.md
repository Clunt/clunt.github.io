# O(NP)序列比较算法（译）
> 原文 [An O(NP) Sequence Comparison Algorithm](https://publications.mpi-cbg.de/Wu_1990_6334.pdf)

**摘要**
设`A`和`B`分别是长度为`M`、`N`的两个序列，不失一般性的设`N ≥ M`，并且设`D`为它们之间最短编辑字符长度。与`D`相关的参数为字符的删除数量，`P = D/2 - (N - M)/2`。我们给出了一个最坏时间复杂度为O(NP)，预期时间复杂度为O(N + PD)的算法，用来寻找`A`与`B`最短编辑距离。该算法很简单，并且当`A`类似于`B`的子序列时非常高效。它几乎比Myers[9]的`O(ND)`算法快两倍，并且当`A`和`B`的长度相差很大时更加高效。

## 引言
设`A`和`B`分别是长度为`M`、`N`的两个序列，不失一般性的设`N ≥ M`，并且设`D`为它们之间最短编辑字符长度。参数`D`也可称为序列间简单的`Levenshtein距离`[6]。其中最短字符的删除和插入数量也是明确的。特别是最短编辑字符中的删除次数`P`，总是等于`D/2 − (N − M)/2`。
确定两个符号序列间最短编辑字符(`SES`)或者最长公共子序列(`LCS`)的问题已经被广泛研究[2, 4, 5, 7, 9, 11, 14, 16]。Wagner和Fischer等人发明的经典动态编程算法[16]，最坏时间复杂度为O(MN)。Masek和Paterson[7]通过`Four-Russians`技术[1]改进了这个算法，将任意和有限字母表集的最坏时间复杂度分别提升至`O(MN log logN/ log N) `和`O(MN/ log N)`。就输入参数`M`和`N`的边界而言还没有得到改进，但最近有几个依赖于输出字符如`D`和`P`的复杂设计。例如Hunt和Szymanski[5]给出的最坏时间复杂度为`O(R log M)`，where R is the total number of ordered pairs of positions at which the two sequences match. Later, Myers [9], Ukkonen [14], and Nakatsu, et al. [11] gave algorithms with worst-case time complexity O(ND), which are efficient when A and B are similar. Such algorithms have been used in file comparison programs [8] and for economically updating the video screen by a text editing program [10]. This represents an improvement since P = D / 2 − ∆ / 2, where ∆ = N − M, and in practice our algorithm is always twice as fast as the O(ND) algorithms. Its superiority is even more pronounced when the problem is highly asymmetric, i.e., ∆ >> 0.
Our algorithm is best explained by casting the longest common subsequence problem as a shortest paths problem on a grid-like graph called an edit graph (e.g., see [9]). The algorithm improves upon Myers’s algorithm [9] by exploring fewer of the vertices in the edit graph. It does so by using a path-compression technique that has been used as a heuristic for shortest paths prob- lems [13]. This technique was also used by Hadlock [2] to give an O(NP) sequence comparison algorithm, however, Hadlock used a version of Dijkstra’s algorithm and thus the expected running time of his algorithm is also O(NP), whereas the expected running time of our algorithm is O(N + PD). Our fusion of a notion of compressed distances and Myers’s greedy approach give an O(NP) algorithm that is very simple and thus very efficient in practice. The algorithm’s dependence on P implies that it is particularly efficient when A is similar to a subsequence of the longer sequence B. In fact, the algorithm is O(N) when A is a subsequence of B. By using Hirschberg’s divide-and-conquer technique [3, 9], the algorithm can be modified to deliver a shor- test edit script using only linear space.

## 前置部分
设`A = a1a2a3...aM`，`B = b1b2b3...bN`，`M`和`N`分别为两个字符串的长度，且`N ≥ M`。如果序列`C = c1 c2 c3 ...cL`可以通过从序列`A`中删除些字符派生出来，则称其为`A`的`子序列`。如果`C`同时是`A`和`B`的子序列，则称其为`A`和`B`的`公共子序列`。如果`C`的长度是`A`和`B`所有公共子序列中最大的，则称其为`最长公共子序列`。
