# 微前端架构
> ☆☆☆☆☆
> 本文核心思路：系统架构是解决根本上的复杂性，表象问题的解决只是顺带的事情，与业务场景无关，是抽象的东西
> 主要放分析后的结论，会尽量避免延展探讨
如果“微前端架构”名称印象对阅读造成干扰，可点此处一键置换为“小cc前端架构”，本意希望大家不要过于纠结于名词概念。

## 什么是微前端
“Micro frontends”出自…………，本文不是嚼碎喂嘴里的科普文，不知道自己看附录。
现在微前端概念、方案的背景、共同特点：？。解决的问题：？。方案：？。特别要提的：？。
康威定律(Conway’s Law)所言，设计系统的组织，其产生的设计和架构等价于组织间的沟通结构；微服务与微前端不仅仅是技术架构的变化，还包含了组织方式、沟通方式的变化。(微服务与微前端原理和软件工程，面向对象设计中的原理同样相通，都是遵循单一职责(Single Responsibility)、关注分离(Separation of Concerns)、模块化(Modularity)与分而治之(Divide & Conquer)等基本的原则。)
所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统

拆分解耦
加速体验
侵入性低
学习成本低
统一技术栈
热更新：在开发过程中，我们希望我们的开发体验和开发单页应用的体验一致，也要支持热更新。由于我们的拆分，实际上有两个服务，即基座和子工程，所以我们以上图的方式完成了热更新的支持：在子工程的module.hot中通过再次触发基座工程中的JSONP钩子来通知基座工程，来再次触发renderApp达到子工程更新代码则页面热刷新的目的。主要代码如下：
部署方案：子工程部署只需要把子工程打包，并在上传CDN之后，把配置信息更新即可，因为配置信息中有子工程新的资源地址，这样就达到了发布上线的目的。
回滚方案：Talos取到上个版本（或者某个前版本）的静态资源，再通过Portm更新我们的配置信息即可完成
监控方案：我们分别在子工程的配置信息、静态资源加载等节点上进行了埋点上报，统计子工程加载
代码规模庞大，导致编译时间过长，开发、打包速度越来越慢
项目文件越来越多，导致查找相关文件变得越来越困难
框架无法调整
工程巨大理解困难
上线慢、频繁
服务发现
运行隔离
环境一致
某一个业务的小改动，导致整个项目的打包和部署
一开始去消除物理空间上的隔离，而不是去连接不同的物理空间
    新业务线产品急速增加，同时为了保证三端系统复用效率的最大化，把文件放入同一仓库管理，导致文件数量增长极快，管理及协同开发难度也在不断加大。
    文件越来越多，文件结构越不受控制，业务开发寻址变得越来越困难。
    文件越来越多，开发、构建、部署速度变得越来越慢，开发体验在持续下降。
    不同业务线间没有物理隔离，出现了跨业务线互相引用混乱，例如A业务线出现了B业务线名字的组件。
任何技术的实现都要依托业务场景才会变得有意义
微前端是一种利用微件拆分来达到工程拆分治理的方案，可以解决工程膨胀、开发维护困难等问题
独立部署
独立开发
技术无关
不影响用户体验
✨ Be Technology Agnostic：每个团队都应该能够选择和升级他们的技术栈，而不必与其他团队协调。自定义元素（后面会具体提到）是隐藏实现细节的好方法，同时为其他人提供公共接口。
✨ Isolate Team Code：即使所有团队使用相同的框架，也不要共享运行时。构建独立的应用程序。不要依赖共享状态或全局变量。
✨ Establish Team Prefixes：相互约定命名隔离。为 CSS、浏览器事件、Local Storage 和 Cookies 制定命名空间，以避免冲突和明确其所有权。
✨ Favor Native Browser Features over Custom APIs：使用浏览器事件进行通信，而不是构建全局的 PubSub 系统。如果确实需要构建跨团队 API，请尽量保持简单。（与框架无关，可使用 CustomEvent）
✨ Build a Resilient Site：即使 JavaScript 失败或尚未执行，Web 应用程序的功能仍应有效。可以使用通用渲染和渐进增强来提高用户的感知性能。
复杂性：服务可以更好地分离，每一个服务都足够小，完成完整的定义清晰的职责；
扩展性：每一个服务可以独立横向扩展以满足业务伸缩性，并资源的不必要消耗；
灵活性：每一个服务可以独立失败，允许每个团队决定最适合他们的技术和基础架构；
敏捷性：每一个服务都可以独立开发，测试和部署，并允许团队扩展独立部署和维护服务的交付。
有一个现实案例，严选有个业务功能叫 库存模块，包含 10 来个页面。我们把这个模块整体发布成了一个 npm 包，在多个项目中引用。本来设想是美好的，只需要和 input、select 那样的基础组件去维护就好了。但是，现实击碎了我们的美好想法。这个业务功能模块并不像基础组件一样稳定，一方面，是因为频繁地需求迭代；另一方面，是因为模块过大 bug 变多，导致我们需要频繁修改这个包。所以，每次在开发联调测试阶段都极为繁琐，我们需要不断地在库存模块的项目里调整代码，发布 npm，然后再用到库存模块的各个项目中，逐个更新依赖、构建、部署。这个过程效率低不说，还容易反复和遗漏。
在应用的加载和管理层引入了 jsSandBox，虽然目前仍存在一些问题，但并不妨碍它是我目前为止在市面上见过的考虑比较完善的方案之一。
当然，光有 window reload 不行，页面的刷新会带来用户体验上的下降。所以配合该方案，我们还需要进行以下一些手段优化：
  a. 前端 snapshot + resume，快速恢复应用界面。当前已应用于生产环境。
  b. 主应用使用 SSR 局部直出，使页面在视觉效果上无刷新。当前还没有应用于生产环境。
为了不出现分支混乱、项目庞大、代码冲突、打包麻烦等一系列的问题，借着后端微服务拆分的机会，我们开始对A项目线前端开发和部署方式进行了调整。
模块拆分后，如何解决开发、打包部署，以及项目中的公共依赖和组件复用的问题。
模块的持续演进
用户端必须是「一个系统」的心智，从域名到体验
能够根据功能拆分成多个子应用，每个子应用独立开发独立部署
子应用尽量保证跟传统单页面应用一样的开发体验，不要让开发者有太多学习成本
所有子应用可被统一管理起来，不能无限制的泛滥
代码量达到一定量的时候，单次构建时间很长，开发&发布效率极低
代码库中依赖升级会影响整个应用，而代码量又非常大，导致回归成本极高
变成一个非常臃肿的巨石应用，完全失去灵活性，无论是多人协作还是业务接入成本都会大大增加
业务场景谈技术方案（微前端）都是瞎扯淡——但可以谈系统架构
可以想象正向的自顶向下的拆分远比反向的聚合简单，因为在开发之初你们就能预见功能，约定接口，统一技术栈，提取公共组件等等；而反向聚合下一切都是未知的，任何困难都有可能发生，只能见招拆招
单页面应用到底比多页面好在哪里？上下文，什么情况下不是这样？
注册机制和命名空间——根本上解决的是什么？
把第三方的SaaS应用进行集成，
把第三方私服应用进行集成（比如在公司内部部署的 gitlab）
在相同技术栈下处理以上各种情况等等
"技术栈无关"：5 年陈的项目，需要你在这个项目上持续迭代加功能、如何确保这套技术方案在 3~5 年内还葆有生命力，不会在 3、5 年后变成又一个遗产项目（那 webpack 版本升级呢，每次都跟进吗？别忘了还有 babel、less、typescript 诸如此类呢？别说 3 年，有几个人敢保证自己的项目一年后把所有依赖包升级到最新还能跑起来？）
一个系统由多个子模块整合，一般会由一个大团队维护前端相关。这种协作模式在一定规模后会有缺陷，一方面，所有团队都依赖这个大前端团队，效率的天花板十分明显。另一方面，同时增加了沟通成本。而交由对应的业务方进行维护，会在一定程度上避免此类问题。
假使模块间有依赖，那么管理依赖会有一定的问题
对相关团队前端技能有一定的要求
功能实现冲突，需要有合理的约定
qiankun/OneX(蚂蚁基于qiankun打造的云应用接入平台)
基本上都是做 ToB 软件服务的，没有哪家 ToC 公司会有微前端的诉求！？？为什么不可以
基座，然后让各子应用按照共同的协议去实现：主应用应该如何加载子应用，以及子应用如何被主应用感知、调度，应用之间如何通信等。这个协议不应该包括，子应用要如何确保隔离性、安全性，也就是子应用除了实现一些较为简单的协议之外，跟开发一个正常的 spa 应用应该没有任何差别，包括不应该有 开发、构建、发布 等流程上的侵入。只要子应用实现了这几个协议，其他的东西怎么玩，我们都不需要关心或干预。
解构之后还需要再重组，重组的过程中我们就会碰到各种 隔离性、依赖去重、通信、应用编排 等问题
widget 级别的微前端应用跟业务组件有什么区别？
但是考察是否技术栈无关不能简单看这些 api 设计，还要看是否存在一些隐性耦合。：比如是否要求调用方的 react 版本、是否要求调用方必须提前构造好一些上下文环境才能完成调用。
如果微前端只存在工程上的价值是不值得大张旗鼓去做的。
今天看各 BU 的业务问题，微前端的前提，还是得有主体应用，然后才有微组件或微应用，解决的是可控体系下的前端协同开发问题（含空间分离带来的协作和时间延续带来的升级维护）
应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。
微服务是一个简单而泛化的概念，不同的行业领域、技术背景、业务架构对于微服务的理解与实践也是不一致的。与微服务相对的，即是单体架构的巨石型(Monolithic)应用，典型的即是将所有功能都部署在一个 Web 容器中运行的系统。虽然很多的文章对于巨石型应用颇多诟病，但并不意味着其就真的一无是处，毕竟微服务本身也是有代价的。除了组织的结构之外，微服务往往还要求组织具备快速的环境提供(Rapid Provisioning)与云开发、基本的监控(Basic Monitoring)、快速的应用发布(Rapid Application Deployment)、DevOps 等能力。
此外值得一提的是，微前端化本身是为了保证系统的持续集成与快速迭代，那么对于各个子模块与系统本身的可用性与稳定性势必会带来挑战，这就要求我们在设计微前端解决方案时，考虑持续构建的时机与对应的测试方案；除了标准的单元测试、集成测试、端到端测试之外，我们还需要保证模块的依赖一致性与功能模块的可生成性；关于此部分的详细讨论参阅 Web 自动化测试概述。
应用组合:
  组合时机，在构建时组合，还是在运行时组合
  应用路由，如何根据 URL 加载/导航到不同的页面，如何根据子应用界面的变化切换 URL
  应用加载，确定加载应用的版本，依赖于框架的加载机制，还是采用 AMD 或者 SystemJS 异步加载
应用隔离:
  应用容错，某个应用的崩溃不应影响到其他应用或容器应用；
  样式隔离，避免 CSS 相互污染
  DOM 隔离，避免子应用操作非自身作用域内的结点
应用协调与治理：
  统一配置与切换，主题，利用 CSS Variables 等方式动态换肤
  应用的生命周期，规范化子应用的生命周期，并且在不同生命周期中执行不同的操作
  数据共享，子应用间数据共享
  服务共享，跨应用数据共享与服务调用
  组件共享，可能将某个纯界面组件或者业务组件以插件(Plugin)或者部件(Widget)的方式共享出去；提供某个计算能力。
开发环境：
  跨技术栈支持
  统一的构建流程与规范
  打桩、埋点与 Hijack
微前端的落地，需要考虑到产品研发与发布的完整生命周期；
独立维护的服务
应用的聚合
满足业务快速变化及分布式多团队并行开发的需求
对产品功能进行低风险的局部替换
代码库更小，更内聚、可维护性更高
松耦合、自治的团队可扩展性更好
渐进地升级、更新甚至重写部分前端功能成为了可能
为了解决庞大的一整块后端服务带来的变更与扩展方面的限制
中大规模系统（小系统有意义么？）
微服务架构来解耦服务间依赖
而在前端微服务化上，则是恰恰与之相反的，人们更想要的结果是聚合，尤其是那些 To B（to Bussiness）的应用。
前端遗留系统迁移——兼容遗留系统
指将项目拆分成
独立开发/并行开发
独立部署：就像微服务一样，微前端的独立部署能力是关键。部署范围的减小，带来了风险的降低。每个微前端应用都应具有自己的持续交付途径，不停地构建、测试、部署。
独立运行——隔离：JS空间、css空间、容器
治理复杂性：
  微前端作为一个更加分布式的体系结构，将不可避免地要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等。因此在采用这样的体系结构之前，您需要考虑几个问题：
    你是否有足够的自动化措施来配置和管理所需的其他基础架构？
    你的前端开发、测试和发布过程是否可以扩展到多个应用程序？
    你是否准备好了让决策变得更加分散，甚至难以控制感？
    你将如何确保多个独立的前端代码库的质量、一致性和或治理水平？
技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权
独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
独立运行时 每个子应用之间状态隔离，运行时状态不共享
微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。
共享组件
跨微应用通信：自定义事件通信、框架自带（react/vue）、地址栏
后端通讯
测试
团队自治：每个团队需要围绕业务功能垂直组建，而不是根据技术能力来组建。这为团队带来了更高的凝聚力。
灰度
新能力引入：假设你想构建一个渐进式的Web应用程序，但是你很难将新的功能实现于现有的整体应用中。比如你想开始使用新的 JS 语法（或TypeScript），但是你无法在现有的构建过程中使用对应的构建工具。
前端整体分解
一种将独立的前端应用组成一个更大的整体的架构风格
一些微型前端实现可能导致依赖关系非常重复：
从而增加用户的下载量。而且，团队自治可能会导致团队分散
增量升级：对于许多团队而言，这是开始微前端之旅的首要原因。技术债阻碍了项目的发展，只能重写。为了避免完全重写的风险，我们更希望 逐个替换旧的模块。
简单、解耦的代码库：每个单独的微型前端应用的源代码都将比单个整体前端应用的源代码少得多。这些较小的代码库对于开发人员来说更容易维护。尤其是我们避免了组件间耦合所导致的复杂性。
互相掣肘：你只想扩展你的开发团队，以便多个团队可以同时处理一个产品，但是现有应用中的耦合和复杂度让每个开发者互相掣肘。这些都是真实存在的问题，这些问题极大地降低了大型团队的开发效率。
微前端就是将大而恐怖的东西切成更小、更易于管理的部分，然后明确地表明它们之间的依赖性。我们的技术选择，我们的代码库，我们的团队以及我们的发布流程都应该能够彼此独立地操作和发展，无需过多的协调。
集成方案：后端模板的集成、package 集成、通过 iframe 集成、运行时集成、 Web Component
针对中后台应用的解决方案
  中后台应用由于其应用生命周期长(动辄 3+ 年)等特点，最后演变成一个巨石应用的概率往往高于其他类型的 web 应用。而从技术实现角度，微前端架构解决方案大概分为两类场景：
  单实例：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。通常基于 url 的变化来做子应用的切换。
  多实例：同一时刻可展示多个子应用。通常使用 Web Components 方案来做子应用封装，子应用更像是一个业务组件而不是应用。
  本文将着重介绍单实例场景下的微前端
  MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。

  SPA 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。缺点则在于各应用技术栈之间是强耦合的。

JS Entry vs HTML Entry
多个 Bundle 如何集成？

子应用之间怎样隔离影响？

公共资源如何复用？

子应用间怎样通信？

如何测试？
微前端架构中一般会有个容器应用（container application）将各子应用集成起来，职责如下：

渲染公共的页面元素，比如 header、footer

解决横切关注点（cross-cutting concerns），如身份验证和导航

将各个微前端整合到一个页面上，并控制微前端的渲染区域和时机

集成方式分为 3 类：

服务端集成：如 SSR 拼装模板

构建时集成：如 Code Splitting

运行时集成：如通过 iframe、JS、Web Components 等方式
导致依赖项冗余，增加用户的流量负担

团队自治程度的增加，可能会破坏协作
现有的前端开发、测试、发布流程如何扩展支持很多个应用？

分散的，控制弱化的工具体系及开发实践是否可靠？

针对各式各样的前端代码库，如何建立质量标准？

总之，与之前不同的是，微前端将产生一堆小的东西，因此需要考虑是否具备采用这种方法所需的技术和组织成熟度

技术架构上进一步的扩展性（模块边界清晰、依赖明确）

团队组织上的自治权

开发流程上能独立开发、独立交付

最大的意义在于解锁了多技术栈并存的能力，尤其适用于渐进式重构中架构升级过渡期：

允许低成本尝试新技术栈，甚至允许选用最合适的技术栈做不同的事情（类似于微服务中允许用不同的语言编写不同服务）：


### 概念
### 解决的问题
### 方案
### 优劣分析
微前端优点、弊端
整体架构优点、弊端
### 归类总结
做一些象限类的分析图

对照微服务来看：

一组小的服务（大小没有特别的标准，只要同一团队的工程师理解服务的标识一致即可）

独立的进程（java的tomcat，nodejs等）

轻量级的通信（不是soap，是http协议）

基于业务能力（类似用户服务，商品服务等等）

独立部署（迭代速度快）

无集中式管理（无须统一技术栈，可以根据不同的服务或者团队进行灵活选择）

差异点：

共通处：

可参考点：

“通信”标准，端应用不是单纯的接口调用

技术栈独立：服务有天然的隔离，运行时的端应用面临的场景更复杂，“技术栈独立”需要换个角度考虑、解决，强行靠拢得不偿失。

基于业务能力：抽象程度


## 现在微前端的问题
### 核心问题与分级、不同级别的解决方案
.4 这些方案有哪些问题？

现在的方案问题在哪儿？

### 扩展性/拓展性

## 微前端应该是什么
(重要的是分层架构)
应该是什么和现在的有啥不一样？价值是？为什么应该是这样

## 白话这么多的落地方案和实践呢？
